% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/proj_changes.R
\name{proj_changes}
\alias{proj_changes}
\title{Compute areas of contraction, expansion and stability between scenarios}
\usage{
proj_changes(
  model_projections,
  reference_id = 1,
  consensus = "median",
  include_id = NULL,
  user_thr = NULL,
  by_gcm = TRUE,
  by_change = TRUE,
  general_summary = TRUE,
  force_resample = TRUE,
  write_results = TRUE,
  output_dir = NULL,
  overwrite = FALSE,
  write_bin_models = FALSE,
  return_rasters = FALSE
)
}
\arguments{
\item{model_projections}{a \code{model_projections} object generated by the \code{\link{project_selected()}}() function. This object contains the file paths to the raster projection results and the thresholds used for binarizing the predictions.}

\item{reference_id}{(numeric) the reference ID for the projections corresponding to the current time in \code{model_projections}. Default is 1. See the details section for further information.}

\item{consensus}{(character) the consensus measure to use for calculating changes. Available options are 'mean', 'median', 'range', and 'stdev' (standard deviation). Default is 'median'.}

\item{include_id}{(numeric) a vector containing the reference IDs to include when computing changes. Default is \code{NULL}, meaning all projections will be included. See the details section for further information.}

\item{user_thr}{(numeric) an optional threshold for binarizing the predictions. Default is \code{NULL}, meaning the function will apply the thresholds stored in model_projections, which were calculated earlier using the omission rate from \code{calibration_glmnetmx()}.}

\item{by_gcm}{(logical) whether to compute changes across GCMs. Default is TRUE.}

\item{by_change}{(logical) whether to compute results separately for each change, identifying areas of gain, loss, and stability for each GCM. Default is TRUE.}

\item{general_summary}{(logical) whether to generate a general summary, mapping how many GCMs project gain, loss, and stability for each scenario. Default is TRUE.}

\item{force_resample}{(logical) whether to force the projection rasters to have the same extent and resolution as the raster corresponding to the \code{reference_id}, which represents the current projections. Default is TRUE.}

\item{write_results}{(logical) whether to write the raster files containing the computed changes to the disk. Default is TRUE.}

\item{output_dir}{(character) the directory path where the resulting raster files containing the computed changes will be saved. Only relevant if \code{write_results = TRUE}.}

\item{overwrite}{(logical) whether to overwrite SpatRaster if they already exist. Only applicable if \code{write_results} is set to TRUE. Default is FALSE.}

\item{write_bin_models}{(logical) whether to write the binarized models for each GCM to the disk. Default is FALSE.}

\item{return_rasters}{(logical) whether to return a list containing all the SpatRasters with the computed changes. Default is FALSE, meaning the function will return a NULL object. Setting this argument to TRUE while using multiple GCMs at a large extent and fine resolution may overload the RAM.}
}
\value{
If return_rasters = TRUE,  the function returns a list containing the SpatRasters with the computed changes. The list includes the following elements:
\itemize{
\item Binarized: binarized models for each GCM.
\item Results_by_gcm: computed changes for each GCM.
\item Results_by_change: a list where each SpatRaster represents a specific change.
\item Summary_changes: A general summary that indicates how many GCMs project gain, loss, and stability for each scenario
If return_rasters = FALSE, the function returns a NULL object.
}
}
\description{
This function performs map algebra operations to represent how and where the projected models change over time compared to the current model. The changes encompass loss (contraction), gain (expansion) and stability. If multiple climate models (GCM) are used, it calculates the level of agreement among all GCMs for each emission scenario.
}
\details{
When comparing changes in binarized prodictions over time, there are four possible outcomes:
\itemize{
\item Stable-Suitable: the area remains suitable in both the current and projected times.
\item Stable-Unsuitable: the area remains unsuitable in both the current and projected times.
\item Gain: the area is unsuitable in the current time but becomes suitable in the projected time (indicating expansion).
\item Loss: The area is suitable in the current time but becomes unsuitable in the projected time (indicating contraction).
}

The reference scenario (current conditions) can be accessed in the paths element of the model_projections object (model_projections$path). The ID will differ from 1 only if there is more than one projection for the current conditions.

Specific projections can be included or excluded from the analysis using the \code{include_id} argument. For example, setting 'include_id = c(3, 5, 7)' will compute changes only for scenarios 3, 5, and 7. Conversely, setting 'include_id = -c(3, 5, 7)' will exclude scenarios 3, 5, and 7 from the analysis.
}
\examples{
# Organize and structure future climate variables from WorldClim
# Import the current variables used to fit the model.
# In this case, SoilType will be treated as a static variable (constant across future scenarios).
var <- terra::rast(system.file("extdata", "Current_variables.tif",
                               package = "kuenm2"))
# Create a "Current_raw" folder in a temporary directory and copy the raw variables there.
out_dir_current <- file.path(tempdir(), "Current_raw")
dir.create(out_dir_current, recursive = TRUE)
# Save current variables in temporary directory
writeRaster(var, file.path(out_dir_current, "Variables.tif"))

# Set the input directory containing the raw future climate variables.
# For this example, the data is located in the "inst/extdata" folder.
in_dir <- "inst/extdata/"
# Create a "Future_raw" folder in a temporary directory and copy the raw variables there.
out_dir_future <- file.path(tempdir(), "Future_raw")
# Organize and rename the future climate data, structuring it by year and GCM.
# The 'SoilType' variable will be appended as a static variable in each scenario.
# The files will be renamed following the "bio_" format
organize_future_worldclim(input_dir = in_dir,
                          output_dir = out_dir_future,
                          name_format = "bio_", variables = NULL,
                          fixed_variables = var$SoilType, mask = NULL,
                          overwrite = TRUE)

#Example with GLMNET
# Import example of fitted_models (output of fit_selected())
data("fitted_model_glmnet", package = "kuenm2")

# Prepare projections using fitted models to check variables
pr <- prepare_proj(models = fitted_model_glmnet,
                   present_dir = out_dir_current,
                   past_dir = NULL,
                   past_period = NULL,
                   past_gcm = NULL,
                   future_dir = out_dir_future,
                   future_period = c("2041-2060", "2081-2100"),
                   future_pscen = c("ssp126", "ssp585"),
                   future_gcm = c("ACCESS-CM2", "MIROC6"),
                   write_file = FALSE,
                   filename = NULL,
                   raster_pattern = ".tif*")

#Create folder to save projection results
out_dir <- file.path(tempdir(), "Projection_results/glmnet")
dir.create(out_dir, recursive = TRUE)

# Project selected models for multiple scenarios
p <- project_selected(models = fitted_model_glmnet,
                      projection_data = pr,
                      out_dir = out_dir,
                      consensus_per_model = TRUE,
                      consensus_general = TRUE,
                      consensus = c("median", "range", "mean", "stdev"),
                      write_replicates = FALSE,
                      clamping = FALSE,
                      var_to_clamp = NULL,
                      type = "cloglog",
                      overwrite = TRUE,
                      parallel = FALSE,
                      ncores = 1,
                      parallelType = "doSNOW",
                      progress_bar = TRUE,
                      verbose = TRUE)

# Compute areas of contraction, expansion and stability between scenarios
changes <- proj_changes(model_projections = p,
                        reference_id = 1,
                        consensus = "median",
                        include_id = NULL,
                        user_thr = NULL,
                        by_gcm = TRUE,
                        by_change = TRUE,
                        general_summary = TRUE,
                        force_resample = TRUE,
                        write_results = FALSE,
                        output_dir = NULL,
                        overwrite = FALSE,
                        write_bin_models = FALSE,
                        return_rasters = TRUE)
changes$Binarized #SpatRaster with the binarized models for each GCM
changes$Results_by_gcm #SpatRaster with the computed changes for each GCM
changes$Results_by_change #List containing the SpatRaster with each computed change for each GCM
changes$Summary_changes #SpatRaster with the general summary

}
