#' Prediction variance coming from distinct sources in ENMs
#'
#' @description
#' This function calculates the variance in model predictions, distinguishing between the different sources of variation. The potential sources include replicates, model parameterizations, and general circulation models (GCMs). The latter is considered only when time projections are performed.
#'
#' @param model_projections a `model_projections` object generated by the \code{\link{project_selected()}}() function. This object contains the file paths to the raster projection results and the thresholds used for binarizing the predictions.
#' @param by_replicate (logical) whether to compute the variance originating from replicates.
#' @param by_gcm (logical) whether to compute the variance originating from general circulation models (GCMs)
#' @param by_model (logical) whether to compute the variance originating from model parameterizations.
#' @param consensus (character) (character) the consensus measure to use for calculating changes. Available options are 'mean', 'median', 'range', and 'stdev' (standard deviation). Default is 'median'.
#' @param write_files (logical) whether to write the raster files containing the computed variance to the disk. Default is TRUE.
#' @param output_dir (character) the directory path where the resulting raster files containing the computed changes will be saved. Only relevant if `write_results = TRUE`.
#' @param return_rasters (logical) whether to return a list containing all the SpatRasters with the computed changes. Default is FALSE, meaning the function will return a NULL object.
#' @param progress_bar (logical) whether to display a progress bar during processing. Default is TRUE.
#' @param verbose (logical) whether to display messages during processing. Default is TRUE.
#' @param overwrite whether to overwrite SpatRaster if they already exists. Only applicable if `write_files` is set to TRUE. Default is FALSE.
#'
#' @return If return_rasters = TRUE, the function returns a list containing the SpatRasters with the computed variances, categorized by replicate, model, and GCMs.
#' @export
#' @importFrom utils txtProgressBar setTxtProgressBar
#' @importFrom terra rast nlyr mean app writeRaster
#'
#' @examples
#' # Organize and structure future climate variables from WorldClim
#' # Import the current variables used to fit the model.
#' # In this case, SoilType will be treated as a static variable (constant across future scenarios).
#' var <- terra::rast(system.file("extdata", "Current_variables.tif",
#'                                package = "kuenm2"))
#' # Create a "Current_raw" folder in a temporary directory and copy the raw variables there.
#' out_dir_current <- file.path(tempdir(), "Current_raw")
#' dir.create(out_dir_current, recursive = TRUE)
#' # Save current variables in temporary directory
#' writeRaster(var, file.path(out_dir_current, "Variables.tif"))
#'
#' # Set the input directory containing the raw future climate variables.
#' # For this example, the data is located in the "inst/extdata" folder.
#' in_dir <- "inst/extdata/"
#' # Create a "Future_raw" folder in a temporary directory and copy the raw variables there.
#' out_dir_future <- file.path(tempdir(), "Future_raw")
#' # Organize and rename the future climate data, structuring it by year and GCM.
#' # The 'SoilType' variable will be appended as a static variable in each scenario.
#' # The files will be renamed following the "bio_" format
#' organize_future_worldclim(input_dir = in_dir,
#'                           output_dir = out_dir_future,
#'                           name_format = "bio_", variables = NULL,
#'                           fixed_variables = var$SoilType, mask = NULL,
#'                           overwrite = TRUE)
#'
#' #Example with GLMNET
#' # Import example of fitted_models (output of fit_selected())
#' data("fitted_model_glmnet", package = "kuenm2")
#'
#' # Prepare projections using fitted models to check variables
#' pr <- prepare_proj(models = fitted_model_glmnet,
#'                    present_dir = out_dir_current,
#'                    past_dir = NULL,
#'                    past_period = NULL,
#'                    past_gcm = NULL,
#'                    future_dir = out_dir_future,
#'                    future_period = c("2041-2060", "2081-2100"),
#'                    future_pscen = c("ssp126", "ssp585"),
#'                    future_gcm = c("ACCESS-CM2", "MIROC6"),
#'                    write_file = FALSE,
#'                    filename = NULL,
#'                    raster_pattern = ".tif*")
#'
#' #Create folder to save projection results
#' out_dir <- file.path(tempdir(), "Projection_results/glmnet")
#' dir.create(out_dir, recursive = TRUE)
#'
#' # Project selected models for multiple scenarios
#' #Set write_replicates = TRUE to compute variance coming from replicates
#' p <- project_selected(models = fitted_model_glmnet,
#'                       projection_data = pr,
#'                       out_dir = out_dir,
#'                       consensus_per_model = TRUE,
#'                       consensus_general = TRUE,
#'                       consensus = c("median", "range", "mean", "stdev"),
#'                       write_replicates = TRUE,
#'                       clamping = FALSE,
#'                       var_to_clamp = NULL,
#'                       type = "cloglog",
#'                       overwrite = TRUE,
#'                       parallel = FALSE,
#'                       ncores = 1,
#'                       parallelType = "doSNOW",
#'                       progress_bar = TRUE,
#'                       verbose = TRUE)
#'
#' # Compute variance from distinct sources
#' v <- modvar(model_projections = p,
#'             by_replicate = TRUE,
#'             by_gcm = TRUE,
#'             by_model = TRUE,
#'             consensus = "median",
#'             write_files = FALSE,
#'             output_dir = NULL,
#'             return_rasters = TRUE,
#'             progress_bar = FALSE,
#'             verbose = TRUE,
#'             overwrite = FALSE)
#' plot(v$Present$by_rep) #Variance coming from replicates in Present projection
#' plot(v$Present$by_model) #Variance coming from models in Present projection
#' plot(v$`Future_2041-2060_ssp126`$by_rep) #Variance coming from replicates in one of the future projections
#' plot(v$`Future_2041-2060_ssp126`$by_model) #Variance coming from models in one of the future projections
#' plot(v$`Future_2041-2060_ssp126`$by_gcm) #Variance coming from GCMs in one of the future projections


modvar <- function(model_projections,
                   by_replicate = TRUE,
                   by_gcm = TRUE,
                   by_model = TRUE,
                   consensus = "median",
                   write_files = TRUE,
                   output_dir = NULL,
                   return_rasters = FALSE,
                   progress_bar = FALSE,
                   verbose = TRUE,
                   overwrite = FALSE){
  #Check data
  if (!inherits(model_projections, "model_projections")) {
    stop(paste0("Argument model_projections must be a model_projections object, not ",
                class(model_projections)))
  }
  if (!inherits(by_replicate, "logical")) {
    stop(paste0("Argument by_replicate must be logical, not ",
                class(by_replicate)))
  }
  if (!inherits(by_gcm, "logical")) {
    stop(paste0("Argument by_gcm must be logical, not ",
                class(by_gcm)))
  }
  if (!inherits(by_model, "logical")) {
    stop(paste0("Argument by_model must be logical, not ",
                class(by_model)))
  }
  if (!inherits(consensus, "character")) {
    stop(paste0("Argument consensus must be a character, not ",
                class(consensus)))
  }
  if (length(consensus) > 1) {
    stop("Argument consensus must be a unique value.
    The available options are: 'median', 'range', 'mean' or 'stdev'")
  }
  consensus_out <- setdiff(consensus, c("median", "range", "mean", "stdev"))
  if(length(consensus_out) > 0){
    stop("Invalid consensus provided.
  The available options are: 'median', 'range', 'mean' or 'stdev'")
  }
  if (!inherits(write_files, "logical")) {
    stop(paste0("Argument write_files must be logical, not ",
                class(write_files)))
  }
  if(write_files & is.null(output_dir)){
    stop("If write_files = TRUE, output_dir must be specified")
  }
  if(write_files & !inherits(output_dir, "character")) {
    stop(paste0("Argument output_dir must be a character, not ",
                class(output_dir)))
  }
  if(!return_rasters & !write_files) {
    stop("return_rasters and write_files cannot both be set to FALSE.
            Changing return_rasters or/and write_files to TRUE")
    return_rasters <- TRUE
  }
  if (!inherits(return_rasters, "logical")) {
    stop(paste0("Argument return_rasters must be logical, not ",
                class(return_rasters)))
  }
  if (!inherits(progress_bar, "logical")) {
    stop(paste0("Argument progress_bar must be logical, not ",
                class(progress_bar)))}
  if (!inherits(verbose, "logical")) {
    stop(paste0("Argument verbose must be logical, not ",
                class(verbose)))}
  if (!inherits(overwrite, "logical")) {
    stop(paste0("Argument overwrite must be logical, not ",
                class(overwrite)))}

  #Create directory if necessary
  if(write_files){
    out_dir <- file.path(output_dir, "variance")
    dir.create(out_dir, recursive = TRUE, showWarnings = FALSE)
  }
  #### Get data ####
  d <- model_projections[["paths"]]


  # Get unique combinations of Time, Period, ssp and Scenario
  uc <- unique(d[, c("Time", "Period", "ssp", "Scenario")])

  #Show progress bar?
  if (progress_bar) {
    pb <- utils::txtProgressBar(0, nrow(uc), style = 3)
    progress <- function(n) utils::setTxtProgressBar(pb, n) }

  ####Iteration over combinations####
  res <- lapply(1:nrow(uc), function(z){
    #To test
    #z = 1
    ssp <- uc$ssp[z]
    period <- uc$Period[z]
    time <- uc$Time[z]
    scenario <- uc$Scenario[z]

    # Filter dataframe to current combination
    d_p <- d[
      (is.na(d$ssp) | d$ssp == ssp) &
        (is.na(d$Period) | d$Period == period) &
        (is.na(d$Scenario) | d$Scenario == scenario) &
        (is.na(d$Time) | d$Time == time), ]

    # Get all paths
    paths <- d_p$output_path

    #### By replicate ####
    if(by_replicate){
        if(verbose) {
        message("\nCalculating prediction variance coming from distinct replicates: scenario ", z, " of ", nrow(uc))
      }
      #Variance of means

      #### By replicates ####
      # Get variance of replicates in each gcm, than get the average across gcms
      var_rep_by_gcm <- terra::rast(lapply(paths, var_models_rep_by_gcm))
      var_rep <- terra::mean(var_rep_by_gcm)
      } else {#End of by_replicate
        var_rep <- NULL}

    #### By Model ####
    if(by_model){
      if(verbose) {
        message("Calculating prediction variance coming from distinct models: scenario ", z, " of ", nrow(uc))}
      # Get variance of models in each gcm, than get the average
      var_model_by_gcm <- terra::rast(lapply(paths, var_models_model_by_gcm, consensus))
      var_model <- terra::mean(var_model_by_gcm)
      names(var_model) <- "by_model"
    } else { #End of by model
      var_model <-  NULL}


    ####By GCM####
    if(by_gcm & period != "Present"){
      if(verbose) {
        message("Calculating prediction variance coming from distinct GCMs: scenario ", z, " of ", nrow(uc))}
      var_gcm <- var_models_across_gcm(paths = paths, consensus = consensus)
      names(var_gcm) <- "by_gcm"
    } else {
      var_gcm <- NULL}#End of by_gcm

   all_var <- terra::rast(c("by_rep" = var_rep,
                 "by_model" = var_model,
                 "by_gcm" = var_gcm))


    #Write results
    if(write_files){
      #Name of raster
      nr <- gsub("_NA", "",
                 paste(time, period, scenario, ssp, sep = "_"))
      if(nr == "Present_Present_Present"){
        nr = "Present"
      }
      terra::writeRaster(all_var,
                         filename = file.path(out_dir,
                                              paste0(nr, ".tif")),
                         overwrite = overwrite)
    }

    #Progress bar
    if(progress_bar){
      utils::setTxtProgressBar(pb, z) }

    if(return_rasters){
      return(all_var)} else {
        return(invisible(NULL))}
    }) #End of res

  if(return_rasters){
    names(res) <- gsub("Present_Present_Present", "Present",
                       gsub("_NA", "",
                       paste(uc$Time, uc$Period, uc$ssp, uc$Scenario, sep = "_")))
    return(res) } else {
    return(invisible(NULL))
  }
} #End of function


# # #Objects to test function internally
# library(terra)
# by_replicate = TRUE
# by_gcm = TRUE
# by_model = TRUE
# model_projections = p
# consensus = "mean"
# write_files = TRUE
# output_dir = "../test_kuenm2/Projection_results/"
# return_rasters = FALSE
# progress_bar = TRUE
# verbose = TRUE
# overwrite = TRUE
#
# #Test function
# v <- modvar(model_projections =model_projections, #output of project_selected_glmnetx
#             by_replicate = TRUE,
#             by_gcm = FALSE,
#             by_model = TRUE,
#             consensus = "mean", #To calculate variance by_gcm and by_model
#             write_files = FALSE,
#             output_dir = "../test_kuenm2/Projection_results/",
#             return_rasters = TRUE,
#             progress_bar = TRUE,
#             verbose = TRUE,
#             overwrite = TRUE)
#
