#' Compute areas of contraction, expansion and stability between scenarios
#'
#' @description
#' This function performs map algebra operations to represent how and where the projected models change over time compared to the current model. The changes encompass loss (contraction), gain (expansion) and stability. If multiple climate models (GCM) are used, it calculates the level of agreement among all GCMs for each emission scenario.
#'
#' @param model_projections a `model_projections` object generated by the \code{\link{project_selected()}}() function. This object contains the file paths to the raster projection results and the thresholds used for binarizing the predictions.
#' @param reference_id (numeric) the reference ID for the projections corresponding to the current time in `model_projections`. Default is 1. See the details section for further information.
#' @param consensus (character) the consensus measure to use for calculating changes. Available options are 'mean', 'median', 'range', and 'stdev' (standard deviation). Default is 'median'.
#' @param include_id (numeric) a vector containing the reference IDs to include when computing changes. Default is `NULL`, meaning all projections will be included. See the details section for further information.
#' @param user_thr (numeric) an optional threshold for binarizing the predictions. Default is `NULL`, meaning the function will apply the thresholds stored in model_projections, which were calculated earlier using the omission rate from `calibration_glmnetmx()`.
#' @param by_gcm (logical) whether to compute changes across GCMs. Default is TRUE.
#' @param by_change (logical) whether to compute results separately for each change, identifying areas of gain, loss, and stability for each GCM. Default is TRUE.
#' @param general_summary (logical) whether to generate a general summary, mapping how many GCMs project gain, loss, and stability for each scenario. Default is TRUE.
#' @param force_resample (logical) whether to force the projection rasters to have the same extent and resolution as the raster corresponding to the `reference_id`, which represents the current projections. Default is TRUE.
#' @param write_results (logical) whether to write the raster files containing the computed changes to the disk. Default is TRUE.
#' @param output_dir (character) the directory path where the resulting raster files containing the computed changes will be saved. Only relevant if `write_results = TRUE`.
#' @param overwrite (logical) whether to overwrite SpatRaster if they already exist. Only applicable if `write_results` is set to TRUE. Default is FALSE.
#' @param write_bin_models (logical) whether to write the binarized models for each GCM to the disk. Default is FALSE.
#' @param return_rasters (logical) whether to return a list containing all the SpatRasters with the computed changes. Default is FALSE, meaning the function will return a NULL object. Setting this argument to TRUE while using multiple GCMs at a large extent and fine resolution may overload the RAM.
#'
#' @details
#' When comparing changes in binarized prodictions over time, there are four possible outcomes:
#' - Stable-Suitable: the area remains suitable in both the current and projected times.
#' - Stable-Unsuitable: the area remains unsuitable in both the current and projected times.
#' - Gain: the area is unsuitable in the current time but becomes suitable in the projected time (indicating expansion).
#' - Loss: The area is suitable in the current time but becomes unsuitable in the projected time (indicating contraction).
#'
#' The reference scenario (current conditions) can be accessed in the paths element of the model_projections object (model_projections$path). The ID will differ from 1 only if there is more than one projection for the current conditions.
#'
#' Specific projections can be included or excluded from the analysis using the `include_id` argument. For example, setting 'include_id = c(3, 5, 7)' will compute changes only for scenarios 3, 5, and 7. Conversely, setting 'include_id = -c(3, 5, 7)' will exclude scenarios 3, 5, and 7 from the analysis.
#'
#' @return If return_rasters = TRUE,  the function returns a list containing the SpatRasters with the computed changes. The list includes the following elements:
#'  - Binarized: binarized models for each GCM.
#'  - Results_by_gcm: computed changes for each GCM.
#'  - Results_by_change: a list where each SpatRaster represents a specific change.
#'  - Summary_changes: A general summary that indicates how many GCMs project gain, loss, and stability for each scenario
#'  If return_rasters = FALSE, the function returns a NULL object.
#' @export
#'
#' @importFrom terra rast res ext resample writeRaster unique nlyr mean app
#'
#' @examples
#' # Organize and structure future climate variables from WorldClim
#' # Import the current variables used to fit the model.
#' # In this case, SoilType will be treated as a static variable (constant across future scenarios).
#' var <- terra::rast(system.file("extdata", "Current_variables.tif",
#'                                package = "kuenm2"))
#' # Create a "Current_raw" folder in a temporary directory and copy the raw variables there.
#' out_dir_current <- file.path(tempdir(), "Current_raw")
#' dir.create(out_dir_current, recursive = TRUE)
#' # Save current variables in temporary directory
#' writeRaster(var, file.path(out_dir_current, "Variables.tif"))
#'
#' # Set the input directory containing the raw future climate variables.
#' # For this example, the data is located in the "inst/extdata" folder.
#' in_dir <- "inst/extdata/"
#' # Create a "Future_raw" folder in a temporary directory and copy the raw variables there.
#' out_dir_future <- file.path(tempdir(), "Future_raw")
#' # Organize and rename the future climate data, structuring it by year and GCM.
#' # The 'SoilType' variable will be appended as a static variable in each scenario.
#' # The files will be renamed following the "bio_" format
#' organize_future_worldclim(input_dir = in_dir,
#'                           output_dir = out_dir_future,
#'                           name_format = "bio_", variables = NULL,
#'                           fixed_variables = var$SoilType, mask = NULL,
#'                           overwrite = TRUE)
#'
#' #Example with GLMNET
#' # Import example of fitted_models (output of fit_selected())
#' data("fitted_model_glmnet", package = "kuenm2")
#'
#' # Prepare projections using fitted models to check variables
#' pr <- prepare_proj(models = fitted_model_glmnet,
#'                    present_dir = out_dir_current,
#'                    past_dir = NULL,
#'                    past_period = NULL,
#'                    past_gcm = NULL,
#'                    future_dir = out_dir_future,
#'                    future_period = c("2041-2060", "2081-2100"),
#'                    future_pscen = c("ssp126", "ssp585"),
#'                    future_gcm = c("ACCESS-CM2", "MIROC6"),
#'                    write_file = FALSE,
#'                    filename = NULL,
#'                    raster_pattern = ".tif*")
#'
#' #Create folder to save projection results
#' out_dir <- file.path(tempdir(), "Projection_results/glmnet")
#' dir.create(out_dir, recursive = TRUE)
#'
#' # Project selected models for multiple scenarios
#' p <- project_selected(models = fitted_model_glmnet,
#'                       projection_data = pr,
#'                       out_dir = out_dir,
#'                       consensus_per_model = TRUE,
#'                       consensus_general = TRUE,
#'                       consensus = c("median", "range", "mean", "stdev"),
#'                       write_replicates = FALSE,
#'                       clamping = FALSE,
#'                       var_to_clamp = NULL,
#'                       type = "cloglog",
#'                       overwrite = TRUE,
#'                       parallel = FALSE,
#'                       ncores = 1,
#'                       parallelType = "doSNOW",
#'                       progress_bar = TRUE,
#'                       verbose = TRUE)
#'
#' # Compute areas of contraction, expansion and stability between scenarios
#' changes <- proj_changes(model_projections = p,
#'                         reference_id = 1,
#'                         consensus = "median",
#'                         include_id = NULL,
#'                         user_thr = NULL,
#'                         by_gcm = TRUE,
#'                         by_change = TRUE,
#'                         general_summary = TRUE,
#'                         force_resample = TRUE,
#'                         write_results = FALSE,
#'                         output_dir = NULL,
#'                         overwrite = FALSE,
#'                         write_bin_models = FALSE,
#'                         return_rasters = TRUE)
#' changes$Binarized #SpatRaster with the binarized models for each GCM
#' changes$Results_by_gcm #SpatRaster with the computed changes for each GCM
#' changes$Results_by_change #List containing the SpatRaster with each computed change for each GCM
#' changes$Summary_changes #SpatRaster with the general summary
#'
proj_changes <- function(model_projections,
                         reference_id = 1,
                         consensus = "median",
                         include_id = NULL,
                         user_thr = NULL,
                         by_gcm = TRUE,
                         by_change = TRUE,
                         general_summary = TRUE,
                         force_resample = TRUE,
                         write_results = TRUE,
                         output_dir = NULL,
                         overwrite = FALSE,
                         write_bin_models = FALSE, #Write binarized models?
                         return_rasters = FALSE){

  #Check data
  if (!inherits(model_projections, "model_projections")) {
    stop(paste0("Argument model_projections must be a model_projections object, not ",
                class(model_projections)))
  }
  if (!inherits(reference_id, "numeric")) {
    stop(paste0("Argument reference_id must be numeric, not ",
                class(reference_id)))
  }
  if(!reference_id %in% model_projections$paths$id){
    stop("reference_id is not present in model_projections$path")
  }
  #Get time of reference id
  time_reference <- model_projections$paths$Time[model_projections$paths$id ==
                                                   reference_id]
  if(time_reference != "Present"){
    warning("Reference scenario is ", time_reference, ", not the present time.\n",
            "To set the present time as reference scenario, check the IDS in model_projections$path")
  }
  if (!inherits(consensus, "character")) {
    stop(paste0("Argument consensus must be a character, not ",
                class(consensus)))
  }
  if (length(consensus) > 1) {
    stop("Argument consensus must be a unique value.
    The available options are: 'median', 'range', 'mean' or 'stdev'")
  }
  consensus_out <- setdiff(consensus, c("median", "range", "mean", "stdev"))
  if(length(consensus_out) > 0){
    stop("Invalid consensus provided.
  The available options are: 'median', 'range', 'mean' or 'stdev'")
  }
  if(!is.null(include_id) & !inherits(include_id, "numeric")){
    stop(paste0("Argument include_id must be NULL or numeric, not ",
                class(include_id)))
  }
  if(!is.null(user_thr) & !inherits(user_thr, "numeric")){
    stop(paste0("Argument user_thr must be NULL or numeric, not ",
                class(user_thr)))
  }
  if (!inherits(by_gcm, "logical")) {
    stop(paste0("Argument by_gcm must be logical, not ",
                class(by_gcm)))
  }
  if (!inherits(by_change, "logical")) {
    stop(paste0("Argument by_change must be logical, not ",
                class(by_change)))
  }
  if (!inherits(general_summary, "logical")) {
    stop(paste0("Argument general_summary must be logical, not ",
                class(general_summary)))
  }
  if (!inherits(force_resample, "logical")) {
    stop(paste0("Argument force_resample must be logical, not ",
                class(force_resample)))
  }
  if (!inherits(write_results, "logical")) {
    stop(paste0("Argument write_results must be logical, not ",
                class(write_results)))
  }
  if(!return_rasters & !write_results) {
    stop("return_rasters and write_results cannot both be set to FALSE.
            Changing return_rasters or/and write_results to TRUE")
    return_rasters <- TRUE
  }
  if(write_results & is.null(output_dir)){
    stop("If write_results = TRUE, output_dir must be specified")
  }
  if (write_results & !inherits(output_dir, "character")) {
    stop(paste0("Argument output_dir must be a character, not ",
                class(output_dir)))
  }
  if (!inherits(overwrite, "logical")) {
    stop(paste0("Argument overwrite must be logical, not ",
                class(overwrite)))
  }
  if (!inherits(write_bin_models, "logical")) {
    stop(paste0("Argument write_bin_models must be logical, not ",
                class(write_bin_models)))
  }
  if (!inherits(return_rasters, "logical")) {
    stop(paste0("Argument return_rasters must be logical, not ",
                class(return_rasters)))
  }

  #Create directory to save results, if necessary
  if(write_results){
    if(is.null(output_dir)){
      stop("If write_results = TRUE, you must define output_dir")
    }
    out_dir <- file.path(out_dir, "Projection_changes/")
    if(!file.exists(out_dir)){
    dir.create(out_dir, showWarnings = FALSE, recursive = TRUE)
  }
  }

  #Extract threshold
  if(is.null(user_thr)) {
    thr <- model_projections[["thresholds"]][["consensus"]][[consensus]]
  } else {
    thr <- user_thr
  }

  #Remove threshold from projection paths
  model_projections <- model_projections[["paths"]]


  #Get only specified scenarios
  if(!is.null(include_id)) {
    to_include <- include_id[include_id > 0]
    if(length(to_include) > 0) {
      model_projections <- model_projections[model_projections$id %in% to_include,]
    }
    to_exclude <- abs(include_id[include_id < 0])
    if(length(to_exclude) > 0) {
      model_projections <- model_projections[!(model_projections$id %in%
                                               to_exclude),]
    }
  }


  #Get raster of reference
  dir_reference <- model_projections$output_path[which(model_projections$id ==
                                                        reference_id)]
  file_reference <- file.path(dir_reference, "General_consensus.tiff")
  r <- terra::rast(file_reference)[[consensus]]
  names(r) <- model_projections$Time[which(model_projections$id ==
                                                   reference_id)]


  ####Binarize models ####
  r_bin <- binarize_values(x = r, v = thr, new_value = 2)
  #Set levels
  levels(r_bin) <- data.frame(id = c(0, 2),
                          Result = c("Unsuitable",
                                     "Suitable"))
  names(r_bin) = "Present"

  #plot(r_bin)
  #Looping throughout projections to binarize
  pp <- model_projections[model_projections$Time %in% c("Past", "Future"),]

  #Binarize
  proj_bin <- terra::rast(lapply(1:nrow(pp), function(i){
    #Get scenario projection
    d_i <- pp[i,]
    dir_change <- d_i$output_path
    #Get time
    proj_time <- d_i$Time
    file_change <- file.path(dir_change, "General_consensus.tiff")
    r_change <- terra::rast(file_change)[[consensus]]

    #Force resample if necessary
    if(force_resample){
      if(any(terra::res(r) != (terra::res(r_change)) | terra::ext(r) != terra::ext(r_change))){
        r_change <- terra::resample(r_change, r_bin, method = "average")
      }}

    r_change <- binarize_values(x = r_change, v = thr, new_value = 1)
    levels(r_change) <- data.frame(id = c(0, 1),
                                   Result = c("Unsuitable",
                                              "Suitable"))
    return(r_change)
  }))
  #Rename binarizes scenarions
  names(proj_bin) <- paste(pp$Time, pp$Period, pp$ssp, pp$GCM, sep = "_")
  names(proj_bin) <- gsub("_NA_", "_", names(proj_bin))
  #plot(proj_bin[[1:6]])
  if(write_bin_models) {
    terra::writeRaster(x = c(r_bin, proj_bin),
                      filename = file.path(out_dir, "Binarized.tiff"),
                      overwrite = overwrite)
  }


  #Get single scenarios by Time and period
  sc <- unique(pp[,c("Time", "Period", "ssp")])

  ####Identify changes by scenario####
  if(by_gcm | by_change){
  # #Change values of r to compute gain and loss
  # r2 <- binarize_values(r, v = 1, new_value = 2)
  # r2[r2 == 0] <- 1
  # #plot(r2)

  #Table to set levels in raster
  cls <- data.frame(id = c(1, 2, 3, 0),
                    Result = c("Gain",
                               "Loss",
                               "Suitable-stable",
                               "Unsuitable-stable"))

  res_by_gcm <- lapply(proj_bin, function(i){
    #Compute changes
    r_result <- r_bin + i
    #Get legend
    levels(r_result) <- cls
    #plot(r_result)
    return(r_result)
  })

  #Rename res
  names(res_by_gcm) <- names(proj_bin)

  #Rasterize res
  res_by_gcm <- terra::rast(res_by_gcm)
  #plot(res_by_gcm[[1:8]])

  if(write_results & by_gcm){
    terra::writeRaster(x = res_by_gcm,
                       filename = file.path(out_dir, "Changes_by_GCM.tiff"),
                       overwrite = overwrite)
  }

  } #End of by_gcm


  ####Results by change####
  if(by_change) {
  res_by_change <- lapply(1:nrow(sc), function(i){
    sc_i <- sc[i,]
    scenario_i <- paste(sc_i$Time, sc_i$Period, sc_i$ssp, sep = "_")
    scenario_i <- gsub("_NA", "_", scenario_i)
    #Subset results
    res_i <- res_by_gcm[[grep(scenario_i, names(res_by_gcm))]]
    #Looping throught changes
    #Get available changes
    out <- unique(unlist(sapply(res_i, terra::unique, simplify = T)))
    sc_out <- lapply(out, function(x){
      #Get change value id
      out_id <- cls$id[cls$Result == x]
      res_i_bin <- (res_i == out_id) * 1

      #Sum results
      res_i_sum <- sum(res_i_bin) ####Import sum from terra
      #Levels
      l_sum <- data.frame(id = terra::unique(res_i_sum)$sum,
                          Result = paste0(x, " in ", terra::unique(res_i_sum)$sum, " GCMs"))
      levels(res_i_sum) <- l_sum
      return(res_i_sum)
    })
    names(sc_out) <- out
    return(terra::rast(sc_out))
  })
  #Set names by scenarion
  names(res_by_change) <- gsub("_NA", "",
                             paste(sc$Time, sc$Period, sc$ssp, sep = "_"))
  #plot(res_by_change[[1]], main = names(res_by_change[1]))

  #Save results
  if(write_results){
    dir.create(file.path(out_dir, "Results_by_change"))
    sapply(names(res_by_change), function(z){
      terra::writeRaster(x = res_by_change[[z]],
                         filename = file.path(out_dir, "Results_by_change",
                                              paste0(z, ".tif")),
                         overwrite = overwrite)
      })}

  } else {res_by_change <- NULL} #End of by change

  #plot(res_by_change$`Future_2081-2100_ssp585`)
  #plot(res_by_change$`Future_2041-2060_ssp245`)

  ####General summary####
  if(general_summary){
  res_summary <- lapply(1:nrow(sc), function(i){
    sc_i <- sc[i,]
    scenario_i <- paste(sc_i$Time, sc_i$Period, sc_i$ssp, sep = "_")
    scenario_i <- gsub("_NA", "_", scenario_i)
    #Subset results
    res_i <- proj_bin[[grep(scenario_i, names(proj_bin))]]
    #Presence value in present (number of gcms + 1)
    n_gcms <- terra::nlyr(res_i) + 1
    #Change values of present
    r_present <- (r_bin == 2) * n_gcms

    #Sum rasters to get results
    res_sum <- sum(c(r_present, res_i))

    # # preparing description table
    # vals <- sort(na.omit(unique(res_sum[])))
    # #Fix vals
    # if(length(vals) != max(vals)){
    #   vals <- seq(0, max(vals), 1)
    #   vals <- vals[vals != 2]
    # }

    vals <- seq(0, (n_gcms*2 - 1), 1)

    loss <- ceiling(max(vals)/2)
    l_val <- c(loss, vals[vals > loss & vals != max(vals)])
    g_val <- vals[vals < loss & vals != 0]
    gains <- paste0("gain in ", g_val, " GCMs")
    gains[gains == paste0("gain in ", n_gcms - 1, " GCMs")] <- "gain in all GCMs"
    losses <- paste0("loss in ", max(vals) - l_val, " GCMs")
    losses[losses == paste0("loss in ", n_gcms - 1, " GCMs")] <- "loss in all GCMs"
    descriptions <- c("stable, unsuitable in current period and all GCMs", gains,
                      losses, "stable, suitable in current period and all GCMs")
    res_table <- data.frame(Raster_value = vals, Description = descriptions)


    #Set levels
    levels(res_sum) <- res_table
    #plot(res_sum)
    return(res_sum)
  })
  #Set names by scenario
  names(res_summary) <- gsub("_NA", "",
                             paste(sc$Time, sc$Period, sc$ssp, sep = "_"))
  res_summary <- terra::rast(res_summary) #Rasterize
  #plot(res_summary[[1:4]])

  if(write_results){
    terra::writeRaster(x = res_summary,
                       filename = file.path(out_dir, "Changes_summary.tiff"),
                       overwrite = overwrite)
  }



  } else {res_summary <- NULL} #End of general summary


  if(return_rasters){
  #Create final object
  res_final <- list(Binarized = c(r_bin, proj_bin),
                    Results_by_gcm = res_by_gcm,
                    Results_by_change = res_by_change,
                    Summary_changes = res_summary)
  return(res_final) } else {
    return(invisible(NULL))
  }

} #End of function


# #To test function internally
# model_projections =p
# reference_id = 1
# consensus = "median"
# include_id = NULL
# user_thr = NULL
# by_gcm = TRUE
# by_change = TRUE
# general_summary = TRUE
# force_resample = TRUE
# write_results = FALSE
# output_dir = NULL
# overwrite = FALSE
# write_bin_models = FALSE
# return_rasters = TRUE
